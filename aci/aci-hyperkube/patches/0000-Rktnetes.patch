From 8a4ee8dddd4fb147e897e744f605ce20a6b01ebd Mon Sep 17 00:00:00 2001
From: Julien Balestra <julien.balestra@gmail.com>
Date: Wed, 22 Feb 2017 16:26:19 +0100
Subject: [PATCH] Rktnetes compliant

---
 pkg/kubelet/rkt/image.go |  2 +-
 pkg/kubelet/rkt/rkt.go   | 32 ++++++++++++++++++++++++++++++++
 2 files changed, 33 insertions(+), 1 deletion(-)

diff --git a/pkg/kubelet/rkt/image.go b/pkg/kubelet/rkt/image.go
index 8fefad9..57498ed 100644
--- a/pkg/kubelet/rkt/image.go
+++ b/pkg/kubelet/rkt/image.go
@@ -80,7 +80,7 @@ func (r *Runtime) PullImage(image kubecontainer.ImageSpec, pullSecrets []api.Sec
 	// Today, `--no-store` will fetch the remote image regardless of whether the content of the image
 	// has changed or not. This causes performance downgrades when the image tag is ':latest' and
 	// the image pull policy is 'always'. The issue is tracked in https://github.com/coreos/rkt/issues/2937.
-	if _, err := r.cli.RunCommand(&config, "fetch", "--no-store", dockerPrefix+img); err != nil {
+	if _, err := r.cli.RunCommand(&config, "fetch", "--insecure-options=all", img); err != nil {
 		glog.Errorf("Failed to fetch: %v", err)
 		return err
 	}
diff --git a/pkg/kubelet/rkt/rkt.go b/pkg/kubelet/rkt/rkt.go
index 5be3f8b..b8a29ed 100644
--- a/pkg/kubelet/rkt/rkt.go
+++ b/pkg/kubelet/rkt/rkt.go
@@ -104,6 +104,10 @@ const (
 	k8sRktStage1NameAnno = "rkt.alpha.kubernetes.io/stage1-name-override"
 	dockerPrefix         = "docker://"
 
+	// This annotation allows a k8s rkt runtime to create directories inside the Systemd with
+	// ExecStartPre=/bin/mkdir -pv content-of-the-annotation
+	k8sRktHostCreateDirectories = "rkt.kubernetes.io/host-create-directories"
+
 	authDir            = "auth.d"
 	dockerAuthTemplate = `{"rktKind":"dockerAuth","rktVersion":"v1","registries":[%q],"credentials":{"user":%q,"password":%q}}`
 
@@ -1111,6 +1115,27 @@ func (r *Runtime) getSelinuxContext(opt *api.SELinuxOptions) (string, error) {
 	return strings.Join(ctx, ":"), nil
 }
 
+// Rkt doesn't create the directory if not existing
+// Use the annotations of the Pod to create an ExecStartPre=/bin/mkdir -pv [...]
+func hostCreateDirectoriesByAnnotations(annotations map[string]string) (string, bool) {
+	if val, ok := annotations[k8sRktHostCreateDirectories]; ok {
+		return "/bin/mkdir -pv " + val, true
+	}
+	return "", false
+}
+
+// From the generateName or the podName return a basename for improve the logging with the Journal
+// journalctl -t podBaseName
+func constructSyslogIdentifier(generateName string, podName string) string {
+	if len(generateName) > 1 && generateName[len(generateName)-1] == '-' {
+		return generateName[0 : len(generateName)-1]
+	}
+	if len(generateName) > 0 {
+		return generateName
+	}
+	return podName
+}
+
 // preparePod will:
 //
 // 1. Invoke 'rkt prepare' to prepare the pod, and get the rkt pod uuid.
@@ -1177,12 +1202,19 @@ func (r *Runtime) preparePod(pod *api.Pod, podIP string, pullSecrets []api.Secre
 		// This enables graceful stop.
 		newUnitOption("Service", "KillMode", "mixed"),
 		newUnitOption("Service", "TimeoutStopSec", fmt.Sprintf("%ds", getPodTerminationGracePeriodInSecond(pod))),
+		// Ops helpers
+		newUnitOption("Unit", "Description", pod.Name),
+		newUnitOption("Service", "SyslogIdentifier", constructSyslogIdentifier(pod.GenerateName, pod.Name)),
 		// Track pod info for garbage collection
 		newUnitOption(unitKubernetesSection, unitPodUID, string(pod.UID)),
 		newUnitOption(unitKubernetesSection, unitPodName, pod.Name),
 		newUnitOption(unitKubernetesSection, unitPodNamespace, pod.Namespace),
 		newUnitOption(unitKubernetesSection, unitPodHostNetwork, fmt.Sprintf("%v", hostNetwork)),
 	}
+	// Volumes Handler
+	if mkdirCommand, ok := hostCreateDirectoriesByAnnotations(pod.Annotations); ok {
+		units = append(units, newUnitOption("Service", "ExecStartPre", mkdirCommand))
+	}
 
 	if pod.Spec.SecurityContext != nil && pod.Spec.SecurityContext.SELinuxOptions != nil {
 		opt := pod.Spec.SecurityContext.SELinuxOptions
-- 
2.7.4

